S : Single Responsibility Principle (SRP) 

	"Une classe ne doit avoir qu'une seule et unique responsabilité"	

FAIT	- Nouvelle classe Grid avec :
FAIT		- InitGrid deplacé de puissance 4 et morpion
FAIT		- DisplayGrid (ex DisplayPlate de puissance 4 et morpion)
FAIT		- deplacer la methode GetCellPositionFromId depuis Morpion

FAIT	- Nouvelle classe Input avec :
FAIT		- InputPlayer (a renomer, deplacé de puissance 4 et morpion)
FAIT		- BotRandomInputGenerator (a renomer, deplacé de puissance 4 et morpion)
FAIT		- input pour AskGame dans Launcher.cpp
FAIT		- input pour AskGameType dans Puissance 4 et Morpion
FAIT		- input pour AskPlayersName dans Puissance 4 et Morpion)

FAIT	- Classe Game avec :
FAIT		- remonter ce qui n'est pas override depuis Morpion et Puissance 4 dans Game
FAIT		- renommer PlayGame en PlayRound

?	- Créer une classe Checks ?


O : Open/Closed Principle

	"Les entités doivent être ouvertes à l'extension et fermées à la modification"

FAIT	- Classe Input (ex fonctions Input de morpion et puissance 4) :
FAIT		- Scinder la fonction InputPlayer en 2 fonctions (penser a renomer) : 
FAIT			- 1 InputBot, 1 InputPlayer



L : Liskov’s Substitution Principle (LSP)

	"Les objets dans un programme doivent être remplaçables par des instances de leur sous-type sans pour autant altérer le bon fonctionnement du programme"
	L’idée du principe est que les enfants ne peuvent pas faire plus ou moins que leur parent.

	4 conditions :
OK		- La signature des fonctions (paramètres et retour) doit être identique entre l’enfant et le parent.
OK		- Les paramètres de la fonction de l’enfant ne peuvent pas être plus nombreux que ceux du parent.
OK		- Le retour de la fonction doit retourner le même type que le parent.
OK		- Les exceptions retournées doivent être les mêmes.

OK	- Principe respecté pour les heritages de Game; rien a faire
	(RQ : sauf pour GetCellPositionFromId dans Morpion; Mais le cas n'est plus a traiter suite aux modifications SRP)



I : Interface Segregation Principle (ISP)

	"Aucun client ne devrait être forcé d'implémenter des méthodes / fonctions qu'il n'utilise pas"
	
	Equivalent des interfaces en c++ : classes abstraites virtuelles pures 
		C'est le cas de la classe Game

OK	- Nos classes filles utilisent toutes les methodes de la classe mère; principe respecté rien a faire


D : Dependency Inversion Principle (DIP)

	"Une classe doit dépendre de son abstraction, pas de son implémentation"
	Cad : Nous ne savons pas si Player est implementé pour un jeu, si on l'utilise en tant que 
	parametre nous pouvons avoir des erreurs, il vaut mieux appeler/créer une interface qui le contient

	Nous n'avons que le Player passé en parametre pour les fonctions:
			- bool CheckWin(const Player& player) const override;
			- bool CheckWinByLine(const Player& player) const override;
			- bool CheckWinByColumn(const Player& player) const override;
	   		- bool CheckWinByDiagonal(const Player& player) const override;
			- void InputPlayer(Player player) override;

FAIT	- Il faut deplacer les attributs player dans la classe mere Game qui nous sert d'interface
	  ainsi nous serrons certain qu'un heritier de Game contient l'attribut player et cela nous 
	  evitera les bugs lors des appel des methodes ci-dessus